---
title: "cc"
output: html_document
date: '2024-07-15'
---

## Load libraries

```{r}
library(Seurat)
library(cowplot)
library(dplyr)
library(ggplot2)
library(readr)
library(DT)
library(tidyr)
library(patchwork)
library(harmony)
library(CSCORE)
library(WGCNA)
library(pheatmap)
library(corrplot)
library(rtracklayer)
library(clusterProfiler)
library(org.Mm.eg.db)
library(enrichplot)

source("/data/gpfs/projects/punim2183/data_processed/dropEst_analysis_functions.R")
#save.image(file = "dropEst_output.RData")
#load("dropEst_output.RData")

 # knitr::opts_chunk$set(eval = FALSE)
 # 
 # knitr::knit("dropEst_output.Rmd", output = "dropEst_output_analysis.md")

 #rmarkdown::render("dropEst_output.Rmd", output_format = "md_document", output_file = "dropEst_output_analysis.md")
```

The Following steps explain how the Dropest generated count matrices are converted and saved as an rds Seurat objects: 

## Step 1: Reading count matrices from a directory and createing Seurat objects:

For each count matrix type (trunc, FL, orig and both) generated by dropest using different gtf file.

```{r}

# Define the directory containing RDS files
rds_directory_trunc <- "/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/trunc"

# Step 1: Read RDS files into Seurat objects
seurat_list_trunc <- read_rds_to_seurat(rds_directory_trunc)
```

# Step 2: Rename cells in the Seurat objects:

Extract naming patterns from the names of Seurat objects. And rename cell names in each Seurat object using the extracted naming patterns. Then combine multiple Seurat objects into a single Seurat object.

*Extract the naming pattern (e.g., "10X05_1")* 

**input** seurat_objects_trunc (a list of Seurat objects with names like count_matrix.rds_10X05_1.bam.1_trunc.gtf).


**Output** Each Seurat object in seurat_objects_trunc now has cell names prefixed with the corresponding naming pattern (e.g., "10X05_1\_Cell_1").

```{r}
seurat_list_trunc <- rename_cells_in_seurat_objects(seurat_list_trunc)
```

# Step 3: Normalize and merge Seurat objects

Preprocess the combined Seurat object by normalizing, scaling, clustering, and filtering the data. Then save the final Seurat object into an rds file format.

**Input:** List of seurat objects .

**Output:** A Normalised and merged Seurat object with:

```{r}
combined_seurat_trunc <- normalize_and_merge(seurat_list_trunc)
```

# Step 4: Update orig.ident metadata

```{r}
combined_seurat_trunc <- update_orig_ident(combined_seurat_trunc)
```

# Step 5: Process the merged Seurat object

Process the combined Seurat object by scaling, clustering, and filtering the data. 

**Input:** combined_seurat_trunc (the combined Seurat object).

**Output:** A processed Seurat object with:

-   scaled data.

-   PCA, clustering, and UMAP performed.

-   Cells filtered based on mitochondrial content (percent.mt \< 5), feature count (nFeature_RNA \> 200 & nFeature_RNA \< 2500), and RNA count.

```{r}
combined_seurat_trunc <- process_seurat(combined_seurat_trunc)
```

# Step 6: Integrate datasets using Harmony

For addressing batch effect, grouped by orig.ident (try Rpca)

```{r}
combined_seurat_trunc <- run_harmony(combined_seurat_trunc)
DimPlot(combined_seurat_trunc, reduction = "umap", group.by = "orig.ident") 
```

# Step 7: Save the final Seurat object

```{r}
save_seurat_object(combined_seurat_trunc, "combined_seurat_trunc.rds")

# Print a success message
print("Workflow completed successfully! The combined Seurat object has been saved.")
```

```{r}
#seurat_objects_orig <- read_rds_to_seurat("/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/orig")

#seurat_objects_trunc <- read_rds_to_seurat("/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/trunc")

#seurat_objects_FL <- read_rds_to_seurat("/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/FL")



```


*Processing trunc originated Seurat*


```{r}
# Define the directory containing RDS files
rds_directory_trunc <- "/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/trunc"

seurat_list_trunc <- read_rds_to_seurat(rds_directory_trunc)

seurat_list_trunc <- rename_cells_in_seurat_objects(seurat_list_trunc)

combined_seurat_trunc <- normalize_and_merge(seurat_list_trunc)

combined_seurat_trunc <- update_orig_ident(combined_seurat_trunc)

combined_seurat_trunc <- process_seurat(combined_seurat_trunc)

combined_seurat_trunc <- run_harmony(combined_seurat_trunc)

save_seurat_object(combined_seurat_trunc, "combined_seurat_trunc.rds")

# Print a success message
print("Workflow completed successfully! The combined Seurat object has been saved.")

```



*Processing FL originated Seurat*


```{r}
# Define the directory containing RDS files
rds_directory_FL <- "/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/FL"

seurat_list_FL <- read_rds_to_seurat(rds_directory_FL)

seurat_list_FL <- rename_cells_in_seurat_objects(seurat_list_FL)

combined_seurat_FL <- normalize_and_merge(seurat_list_FL)

combined_seurat_FL <- update_orig_ident(combined_seurat_FL)

combined_seurat_FL <- process_seurat(combined_seurat_FL)

combined_seurat_FL <- run_harmony(combined_seurat_FL)

save_seurat_object(combined_seurat_FL, "combined_seurat_FL.rds")

# Print a success message
print("Workflow completed successfully! The combined Seurat object has been saved.")

```

*Processing "Both" originated Seurat*

```{r}
# Define the directory containing RDS files
rds_directory_both <- "/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/both"

seurat_list_both <- read_rds_to_seurat(rds_directory_both)

seurat_list_both <- rename_cells_in_seurat_objects(seurat_list_both)

combined_seurat_both <- normalize_and_merge(seurat_list_both)

combined_seurat_both <- update_orig_ident(combined_seurat_both)

combined_seurat_both <- SCTransform(combined_seurat_both, 
                                  vars.to.regress = c("nCount_RNA"),
                                  conserve.memory = TRUE)

combined_seurat_both <- process_seurat(combined_seurat_both)

combined_seurat_both <- run_harmony(combined_seurat_both)

save_seurat_object(combined_seurat_both, "combined_seurat_both.rds")

# Print a success message
print("Workflow completed successfully! The combined Seurat object has been saved.")


FeaturePlot(combined_seurat_both, features = c("Ntrk2trunc", "Ntrk2FL"))


```

*Processing M10 originated Seurat*
```{r}
# Define the directory containing RDS files
rds_directory_orig <- "/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/orig"

seurat_list_M10 <- read_rds_to_seurat(rds_directory_orig)

seurat_list_M10 <- rename_cells_in_seurat_objects(seurat_list_M10)

combined_seurat_M10 <- normalize_and_merge(seurat_list_M10)

combined_seurat_M10 <- update_orig_ident(combined_seurat_M10)

combined_seurat_M10 <- process_seurat(combined_seurat_M10)

combined_seurat_M10 <- run_harmony(combined_seurat_M10)

save_seurat_object(combined_seurat_M10, "combined_seurat_M10.rds")

# Print a success message
print("Workflow completed successfully! The combined Seurat object has been saved.")

```



## Gene expression analysis:

```{r}

gene_expression_Ntrk2_trunc <- FetchData(combined_seurat_trunc, vars = "Ntrk2trunc")
total_expression_Ntrk2_trunc <- sum(gene_expression_Ntrk2_trunc$"Ntrk2trunc")
total_expression_Ntrk2_trunc

FeaturePlot(combined_seurat_trunc, features = "Ntrk2trunc")

```

## Further analysis: 

```{r}
one_sample_trunc <- readRDS("/data/gpfs/projects/punim2183/samples_processing/count_matrix_files/trunc/count_matrix.rds_10X05_1.bam.1_trunc.gtf.rds")
one_sample_trunc <- one_sample_trunc$cm
one_sample_trunc <- CreateSeuratObject(counts = one_sample_trunc)

dim(one_sample_trunc)

VlnPlot(one_sample_trunc, features = "nFeature_RNA", log = TRUE)
summary(one_sample_trunc$nFeature_RNA)


# 1. Normalize the data
one_sample_trunc <- NormalizeData(one_sample_trunc)

# 2. Find variable features
one_sample_trunc <- FindVariableFeatures(one_sample_trunc, selection.method = "vst", nfeatures = 2000)

# 3. Scale the data
one_sample_trunc <- ScaleData(one_sample_trunc)


# 4. Perform PCA
one_sample_trunc <- RunPCA(one_sample_trunc, npcs = 30)

# 5. Find neighbors and clusters
one_sample_trunc <- FindNeighbors(one_sample_trunc, dims = 1:10)
one_sample_trunc <- FindClusters(one_sample_trunc, resolution = 0.5)

# 6. Run UMAP for visualization
one_sample_trunc <- RunUMAP(one_sample_trunc, dims = 1:10)

# 7. Generate a DimPlot
DimPlot(one_sample_trunc, reduction = "umap", label = TRUE)

```

```{r}
Both_Isoforms_Seurat <- readRDS("/data/gpfs/projects/punim2183/data_processed/combined_seurat_both.rds")
# Check available reductions in the Seurat object
names(Both_Isoforms_Seurat@reductions)


Both_Isoforms_Seurat <- run_harmony(Both_Isoforms_Seurat)
Both_Isoforms_Seurat <- FindNeighbors(Both_Isoforms_Seurat, dims = 1:10)
Both_Isoforms_Seurat <- FindClusters(Both_Isoforms_Seurat, resolution = 0.5)
DimPlot(Both_Isoforms_Seurat, reduction = "umap", group.by = "seurat_clusters", label = TRUE)
DimPlot(Both_Isoforms_Seurat, reduction = "pca")
DimPlot(Both_Isoforms_Seurat, reduction = "umap")
DimPlot(Both_Isoforms_Seurat, group.by = "orig.ident")
table(Both_Isoforms_Seurat$orig.ident)
DimPlot(Both_Isoforms_Seurat, reduction = "umap", label = TRUE)
Both_Isoforms_Seurat <- JoinLayers(Both_Isoforms_Seurat, assay = "RNA")


#saveRDS(Both_Isoforms_Seurat, "Both_Isoforms_Seurat.rds")

FeaturePlot(Both_Isoforms_Seurat, features = c("Ntrk2FL", "Ntrk2trunc"))
ElbowPlot(Both_Isoforms_Seurat)
```

```{r, fig.width=12, fig.height=10}
Both_Isoforms_Seurat <- readRDS("/data/gpfs/projects/punim2183/data_processed/Both_Isoforms_Seurat.rds")

neurons_markers = c("Map2", "Rbfox3", "Tubb3")
oligos_markers = c("Mbp", "Olig1", "Olig2")
astrocytes_markers = c("Gfap", "Aqp4", "Slc1a3")

count_expressing_cells <- function(markers, Both_Isoforms_Seurat) {
  expression_data <- FetchData(Both_Isoforms_Seurat, vars = markers)
  num_cells <- sum(rowSums(expression_data > 0) > 0)
  return(num_cells)
}

FeaturePlot(Both_Isoforms_Seurat, c(neurons_markers, astrocytes_markers, oligos_markers))

# Count cells expressing each set of markers
neurons_cells_expressing <- count_expressing_cells(neurons_markers, Both_Isoforms_Seurat)
oligos_cells_expressing <- count_expressing_cells(oligos_markers, Both_Isoforms_Seurat)
astrocytes_cells_expressing <- count_expressing_cells(astrocytes_markers, Both_Isoforms_Seurat)

print(paste("Number of cells expressing neuron markers:", neurons_cells_expressing))
print(paste("Number of cells expressing oligodendrocyte markers:", oligos_cells_expressing))
print(paste("Number of cells expressing astrocyte markers:", astrocytes_cells_expressing))
```

Assign Clusters to cell types of interest

```{r}

# Join layers in the RNA assay
#Both_Isoforms_Seurat <- JoinLayers(Both_Isoforms_Seurat, assay = "RNA")

cluster_to_celltype <- list(
  Neurons = c(4, 5, 20, 16, 7, 8,22),
  Oligo = c(11, 19, 9, 6, 24, 21),
  Astrocytes = c(3, 2, 23, 25, 26)
)
# Create a vector to store cell type labels
cell_type_labels <- rep(NA, ncol(Both_Isoforms_Seurat))

# Assign specific cell types based on cluster IDs
for (cluster_id in 0:26) {
  if (cluster_id %in% cluster_to_celltype$Neurons) {
    cell_type_labels[Both_Isoforms_Seurat$seurat_clusters == cluster_id] <- "Neurons"
  } else if (cluster_id %in% cluster_to_celltype$Oligo) {
    cell_type_labels[Both_Isoforms_Seurat$seurat_clusters == cluster_id] <- "Oligo"
  } else if (cluster_id %in% cluster_to_celltype$Astrocytes) {
    cell_type_labels[Both_Isoforms_Seurat$seurat_clusters == cluster_id] <- "Astrocytes"
  }
}

# Assign generic labels to remaining clusters
remaining_clusters <- setdiff(0:26, unlist(cluster_to_celltype))
for (i in seq_along(remaining_clusters)) {
  cell_type_labels[Both_Isoforms_Seurat$seurat_clusters == remaining_clusters[i]] <- paste0("cell_type", i)
}

# Add the cell type labels to the Seurat object
Both_Isoforms_Seurat$cell_type <- cell_type_labels

# Set the cell type as the active identity
Idents(Both_Isoforms_Seurat) <- Both_Isoforms_Seurat$cell_type
table(Both_Isoforms_Seurat$cell_type)

DimPlot(Both_Isoforms_Seurat, reduction = "umap", label = TRUE, group.by = "cell_type")

#saveRDS(Both_Isoforms_Seurat, "/data/gpfs/projects/punim2183/data_processed/combined_seurat_both_with_cell_types.rds")
#Both_with_cell_types <- readRDS("/data/gpfs/projects/punim2183/data_processed/combined_seurat_both_with_cell_types.rds")
# Extract metadata
Both_metadata <- Both_Isoforms_Seurat@meta.data
head(Both_metadata)


# Filter metadata for cell_type1, cell_type9, and cell_type10
cell_type_info <- Both_metadata[Both_metadata$cell_type %in% c("cell_type1", "cell_type9", "cell_type10"), ]

# Select only the relevant columns
cell_type_info <- cell_type_info[, c("seurat_clusters", "cell_type")]

# Remove duplicate rows
cell_type_info <- unique(cell_type_info)

# View the result
print(cell_type_info)

genes_of_interest = c("Ntrk2FL", "Ntrk2trunc")

VlnPlot(Both_Isoforms_Seurat, features = genes_of_interest, group.by = "cell_type", stack = TRUE, flip = TRUE)

# markers_cell_type7 <- FindMarkers(Both_Isoforms_Seurat, ident.1 = "cell_type7")
# print(head(markers_cell_type7))

```

Subset seurat to cell types of interest for focused plotting 
```{r, fig.width=8}
cell_types_of_interest <- c("Neurons", "Oligo", "Astrocytes")

subset_seurat <- subset(Both_Isoforms_Seurat, subset = cell_type %in% cell_types_of_interest)

genes_of_interest <- c("Ntrk2FL", "Ntrk2trunc", neurons_markers, astrocytes_markers)  

# Define colors for each group
neurons_colors <- c("#1f77b4", "#aec7e8", "#6baed6", "#4292c6")  # Shades of blue
astrocytes_colors <- c("#2ca02c", "#98df8a", "#66c2a4", "#238b45")  # Shades of green

#VlnPlot(subset_seurat, features = genes_of_interest, group.by = "cell_type", stack = TRUE, flip = TRUE)

# Plot for Ntrk2FL + neurons markers
neurons_plot <- VlnPlot(
  subset_seurat,
  features = c(neurons_markers, "Ntrk2FL"),
  group.by = "cell_type",
  cols = neurons_colors,  # Use shades of blue
  pt.size = 0,  # Remove points for clarity
  stack = TRUE,
  flip = TRUE
) +
  ggtitle("Ntrk2FL and Neurons Markers") +
  theme(legend.position = "none")  # Remove legend for cleaner plot

# Plot for Ntrk2trunc + astrocytes markers
astrocytes_plot <- VlnPlot(
  subset_seurat,
  features = c(astrocytes_markers,"Ntrk2trunc"),
  group.by = "cell_type",
  cols = astrocytes_colors,  # Use shades of green
  pt.size = 0,  # Remove points for clarity
  stack = TRUE,
  flip = TRUE, 
  raster = FALSE
) +
  ggtitle("Ntrk2trunc and Astrocytes Markers") +
  theme(legend.position = "none")  # Remove legend for cleaner plot

# Combine plots side by side
combined_plot <- neurons_plot | astrocytes_plot

# Display the combined plot
combined_plot
VlnPlot(subset_seurat, features = c("Ntrk2FL", "Ntrk2trunc"), pt.size = 0)




```

the following code to check Gfap expression
```{r}
# gfap_expression <- FetchData(Both_Isoforms_Seurat, vars = "Gfap")
# 
# gfap_expression$cell_type <- Both_Isoforms_Seurat$cell_type
# 
# # Plot Gfap expression across cell types
# ggplot(gfap_expression, aes(x = cell_type, y = Gfap, fill = cell_type)) +
#   geom_violin(scale = "width", trim = TRUE) +
#   theme_minimal() +
#   labs(title = "Gfap Expression Across Cell Types", x = "Cell Type", y = "Expression Level")
```

```{r}

gene_names <- c("Ntrk2trunc", "Ntrk2FL")  
gene_expression <- FetchData(Both_Isoforms_Seurat, vars = gene_names)

num_cells_expressing <- list()

for (gene in gene_names) {
  num_cells_expressing[[gene]] <- sum(gene_expression[[gene]] > 0)
  print(paste("Number of cells expressing", gene, ":", num_cells_expressing[[gene]]))
}

```



## CS-Core/ gene co-expression analysis:

Use SCT rather than logNormalisation because:
-Automatically Handles Sample Merging
Where the hashed code manually combines layers (data.1, data.2, ...) and normalizes per-sample, which is error-prone.

-SCTransform merges all samples while modeling technical variance (UMI depth, batch effects via orig.ident).

-Better Normalization
The hashed code uses crude log-normalization (RNA assay).

-SCTransform uses Pearson residuals (variance-stabilized), ideal for co-expression analysis.

-Simpler Workflow
No need to manually extract/cbind layers or calculate mean expression.

-SCTransform outputs a ready-to-use normalized matrix in the SCT assay.
```{r}

combined_seurat_both <- SCTransform(Both_Isoforms_Seurat, 
                                  vars.to.regress = c("nCount_RNA", "orig.ident"))
# counts_matrix <- LayerData(Both_Isoforms_Seurat, assay = "RNA", layer = "data")
# counts_matrix <- as.matrix(counts_matrix)  # Convert to dense matrix
# combined_matrix <- do.call(cbind, lapply(sample_names, function(x) {
#   LayerData(Both_Isoforms_Seurat, assay = "RNA", layer = x)
# }))

# Directly access the normalized matrix (Pearson residuals)
sct_matrix <- GetAssayData(combined_seurat_both, assay = "SCT", layer = "scale.data")

# Select top 5,000 variable genes (better than mean_exp for co-expression)
genes_selected <- VariableFeatures(combined_seurat_both)[1:5000]

```
```{r}

# Step 1: Extract normalized data
normalized_data <- LayerData(Both_Isoforms_Seurat, assay = "RNA", layer = "data")
normalized_data <- as.matrix(normalized_data)  # Convert to dense matrix

# Step 2: Calculate mean expression
mean_exp <- rowMeans(normalized_data)

# Step 3: Select top 5000 genes
genes_selected <- names(sort(mean_exp, decreasing = TRUE))[1:5000]

# Step 4: Subset the normalized data
normalized_data_selected <- normalized_data[genes_selected, ]

# Step 5: Create a minimal Seurat object

seurat_subset <- CreateSeuratObject(counts = normalized_data_selected, assay = "RNA")
seurat_subset$nCount_RNA <- colSums(normalized_data_selected)

# Step 6: Run CSCORE
CSCORE_result <- CSCORE(seurat_subset, genes = genes_selected)

# Step 7: Process CSCORE results
CSCORE_coexp <- CSCORE_result$est
CSCORE_p <- CSCORE_result$p_value

# Adjust p-values using Benjamini-Hochberg (BH) method
p_matrix_BH <- matrix(0, length(genes_selected), length(genes_selected))
p_matrix_BH[upper.tri(p_matrix_BH)] <- p.adjust(CSCORE_p[upper.tri(CSCORE_p)], method = "BH")
p_matrix_BH <- p_matrix_BH + t(p_matrix_BH)

# Filter co-expression matrix based on adjusted p-values
CSCORE_coexp[p_matrix_BH > 0.05] <- 0


```

```{r}

target_gene <- "Ntrk2trunc"

target_gene_expression <- normalized_data[target_gene, ]

# Calculate correlations
correlations <- apply(normalized_data, 1, function(gene_expression) {
  cor(target_gene_expression, gene_expression, method = "pearson")
})

# Convert to a data frame for easier handling
correlation_df <- data.frame(
  gene = names(correlations),
  correlation = correlations,
  row.names = NULL
)

# Sort by absolute correlation
correlation_df <- correlation_df[order(-abs(correlation_df$correlation)), ]

# Filter for significant correlations
significant_correlations <- correlation_df[abs(correlation_df$correlation) > 0.3, ] # 0.5 resulted in zero correlarted genes


# Plot the top 20 correlated genes
top_genes <- head(significant_correlations, 20)
ggplot(top_genes, aes(x = reorder(gene, correlation), y = correlation)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = paste("Top Genes Correlated with", target_gene),
       x = "Gene",
       y = "Correlation") +
  theme_minimal()

top_genes$gene


```

```{r}

get_high_correlation_features <- function(matrix, variable_vector, threshold, method = 'pearson'){
  # taking a matrix and a vector (numerical), find features (rows) that have absolute correlation score (both positive and negative) greater than your set threshold value with your variable vector. 
  correlations <- lapply(1:nrow(matrix), function(x) {cor(as.vector(as.numeric(matrix[x,])),as.vector(variable_vector), method=method)})
  
  correlations <- as.matrix(unlist(correlations))
  
  rownames(correlations) <- rownames(as.matrix(matrix))
  
  high_corr_features <- correlations[which(abs(correlations) > threshold), drop = FALSE]
  
  return(high_corr_features)
  
}

# Extract normalized data (e.g., from the "data" layer)
normalized_data <- LayerData(Both_Isoforms_Seurat, assay = "RNA", layer = "data")
normalized_data <- as.matrix(normalized_data)  # Convert to a dense matrix

# Replace "TargetGene" with the name of your target gene
target_gene <- "Ntrk2trunc"

# Extract expression of the target gene
target_gene_expression <- normalized_data[target_gene, ]
# Define the correlation threshold
threshold <- 0.4  # Adjust as needed

# Calculate correlations
high_corr_genes <- get_high_correlation_features(normalized_data, target_gene_expression, threshold)

# View the results
print(high_corr_genes)


# Select top 10 most correlated genes
if (nrow(high_corr_genes) > 10) {
  top_genes <- head(high_corr_genes[order(-abs(high_corr_genes))], 10)
} else {
  top_genes <- high_corr_genes
  }

# Convert to a matrix for pheatmap
top_genes_matrix <- normalized_data[rownames(top_genes), ]

# Generate heatmap
pheatmap(top_genes_matrix, 
         cluster_rows = TRUE, 
         cluster_cols = TRUE,
         fontsize_row = 10, 
         fontsize_col = 8,
         main = paste("Top 10 Genes Co-expressed with", target_gene),
         show_rownames = TRUE, 
         show_colnames = TRUE,
         cellwidth = 15, 
         cellheight = 15)

```
```{r}


# Function to compute high-correlation features
get_high_correlation_features <- function(matrix, variable_vector, threshold, method = 'pearson') {
  correlations <- apply(matrix, 1, function(x) cor(as.numeric(x), as.numeric(variable_vector), method=method))
  
  # Convert to a named matrix
  correlations <- as.matrix(correlations)
  rownames(correlations) <- rownames(matrix)
  
  # Filter genes with absolute correlation above threshold
  high_corr_features <- correlations[abs(correlations) > threshold, , drop=FALSE]
  
  return(high_corr_features)
}

# Extract normalized data
normalized_data <- LayerData(Both_Isoforms_Seurat, assay = "RNA", layer = "data")
normalized_data <- as.matrix(normalized_data)  # Convert to a dense matrix

high_corr_genes <- get_high_correlation_features(normalized_data, target_gene_expression, threshold)

print(high_corr_genes)

# Define the target gene
target_gene <- "Ntrk2FL"

target_gene_expression <- as.vector(normalized_data[target_gene, drop = FALSE])

# Set a co-expression threshold
threshold <- 0.4

high_corr_features <- get_high_correlation_features(normalized_data, target_gene_expression, threshold)

# Convert the result to a data frame for easier viewing (optional)
high_corr_features_df <- data.frame(
  gene = rownames(high_corr_features),
  correlation = as.vector(high_corr_features),
  row.names = NULL
)

# View the high-correlation features
head(high_corr_features_df)


top_5_genes <- coexp_df$gene[1:5]

top_5_coexp <- normalized_data[top_5_genes, ]

pheatmap(top_5_coexp)

# Set color scale limits
# Normalize the data (e.g., scale rows or columns)
# Subset the matrix to include only the top 10 genes for rows and columns
top_10_coexp_subset <- top_5_coexp[, top_5_genes]

# Create the heatmap
pheatmap(top_5_coexp_subset, 
         #color = my_colors,
         cluster_rows = TRUE, 
         cluster_cols = TRUE,
         fontsize_row = 10, 
         fontsize_col = 8,
         main = paste("Top 10 Genes Co-expressed with", target_gene),
         show_rownames = TRUE, 
         show_colnames = TRUE,
         cellwidth = 15, 
         cellheight = 15)


```


extracting correlations using cs-core correlation matrix (instead of the normalised data) resulted in much more genes being correlated with the target gene

```{r}
target_gene_expression_cs <- CSCORE_coexp[target_gene, ]

high_corr_genes_cs <- get_high_correlation_features(CSCORE_coexp, target_gene_expression_cs, threshold)

print(high_corr_genes_cs)

# Set a co-expression threshold
threshold <- 0.4

# Find genes with significant co-expression
significant_coexp_genes_cs <- target_gene_expression_cs[abs(target_gene_expression_cs) > threshold]

# Sort by absolute co-expression strength
significant_coexp_genes_cs <- significant_coexp_genes_cs[order(-abs(significant_coexp_genes_cs))]

# Convert to a data frame for easier handling
coexp_df_cs <- data.frame(
  gene = names(significant_coexp_genes_cs),
  coexpression = significant_coexp_genes_cs,
  row.names = NULL
)

# View the results
print(coexp_df_cs)
top_10_genes <- coexp_df_cs$gene[1:10]

top_10_coexp <- CSCORE_coexp[top_10_genes, ]

pheatmap(top_10_coexp)

# Set color scale limits
# Normalize the data (e.g., scale rows or columns)
# Subset the matrix to include only the top 10 genes for rows and columns
top_10_coexp_subset <- top_10_coexp[, top_10_genes]

# Create the heatmap
pheatmap(top_10_coexp_subset, 
         #color = my_colors,
         cluster_rows = TRUE, 
         cluster_cols = TRUE,
         fontsize_row = 10, 
         fontsize_col = 8,
         main = paste("Top 10 Genes Co-expressed with", target_gene),
         show_rownames = TRUE, 
         show_colnames = TRUE,
         cellwidth = 15, 
         cellheight = 15)

```

GO enrichment

```{r, fig.width=10, fig.height=8}

plot_GO_enrichment <- function(gene_name_vector, gene_id_type = 'ENSEMBL', ontology = 'BP', pval_cutoff = 0.2, OrgDb = 'org.Mm.eg.db'){
  # Taking a vector of gene names, plot GO enrichment dotplot. Default ontology is biological process. 
  
  if(!(gene_id_type %in% c('ENSEMBL','ENTREZID'))){stop("The gene id type you entered doesn't exist. You can choose from 'ENTREZID' and 'ENSEMBL'.")}
  if(!(ontology %in% c('BP','CC','MF'))){stop("The ontology you entered doesn't exist. You can choose from 'BP', 'CC' and 'MF'.")}
  
  enrich_obj <- enrichGO(gene = gene_name_vector,
                         OrgDb = 'org.Mm.eg.db', 
                         keyType = gene_id_type, 
                         ont = ontology, 
                         pAdjustMethod = "BH",
                         pvalueCutoff = pval_cutoff)
  
  enrichplot::dotplot(enrich_obj, 
                      label_format = 100)
  }

brain_gene_list_FL <- c("Gm44562","Atp1a3","Slc12a5","Ntrk2") #the top 3 correlated genes with Ntrk2 truncated isoform
brain_gene_list_trunc <- c("Ntrk2", "Slc6a11", "Sdc4", "Slc1a2", "Atp1a2") # top 3 with full-length isoform
# Convert gene symbols to ENTREZID

converted_genes_trunc <- bitr(brain_gene_list_trunc, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
brain_gene_list_trunc <- converted_genes_trunc$ENTREZID

converted_genes_FL <-bitr(brain_gene_list_FL, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
brain_gene_list_FL <- converted_genes_FL$ENTREZID

# Run GO enrichment with converted gene IDs
go_plot_FL_cc <- plot_GO_enrichment(brain_gene_list_FL, gene_id_type = 'ENTREZID', 
                                 ontology = 'CC', pval_cutoff = 0.05, OrgDb = 'org.Mm.eg.db'+
                                 ggtitle("Gene Ontology Enrichment for Ntrk2FL"))

go_plot_trunc_cc <- plot_GO_enrichment(brain_gene_list_trunc, gene_id_type = 'ENTREZID', 
                                    ontology = 'CC', pval_cutoff = 0.05, OrgDb = 'org.Mm.eg.db'+
                                    ggtitle("Gene Ontology Enrichment for Ntrk2trunc"))
go_plot_FL_mf <- plot_GO_enrichment(brain_gene_list_FL, gene_id_type = 'ENTREZID', 
                                 ontology = 'MF', pval_cutoff = 0.05, OrgDb = 'org.Mm.eg.db'+
                                 ggtitle("Gene Ontology Enrichment for Ntrk2FL"))

go_plot_trunc_mf <- plot_GO_enrichment(brain_gene_list_trunc, gene_id_type = 'ENTREZID', 
                                    ontology = 'MF', pval_cutoff = 0.05, OrgDb = 'org.Mm.eg.db'+
                                    ggtitle("Gene Ontology Enrichment for Ntrk2trunc"))

go_plot_FL_bp <- plot_GO_enrichment(brain_gene_list_FL, gene_id_type = 'ENTREZID', 
                                 ontology = 'BP', pval_cutoff = 0.05, OrgDb = 'org.Mm.eg.db'+
                                 ggtitle("Gene Ontology Enrichment for Ntrk2FL"))

go_plot_trunc_bp <- plot_GO_enrichment(brain_gene_list_trunc, gene_id_type = 'ENTREZID', 
                                    ontology = 'BP', pval_cutoff = 0.05, OrgDb = 'org.Mm.eg.db'+
                                    ggtitle("Gene Ontology Enrichment for Ntrk2trunc"))

go_plot_FL_bp
go_plot_trunc_bp

```

